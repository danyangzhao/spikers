// Prisma schema for Spikers app
// PostgreSQL on Railway

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Player {
  id        String   @id @default(cuid())
  name      String
  emoji     String
  createdAt DateTime @default(now())
  isActive  Boolean  @default(true)
  rating    Int      @default(1000)

  attendances      Attendance[]
  rsvps            RSVP[]
  teamAGames       Game[]            @relation("TeamAPlayers")
  teamBGames       Game[]            @relation("TeamBPlayers")
  ratingHistory    RatingHistory[]
  playerBadges     PlayerBadge[]
  videoTags        VideoPlayerTag[]
  videoAnnotations VideoAnnotation[]
  tournamentTeamsA TournamentTeam[]  @relation("TournamentTeamPlayerA")
  tournamentTeamsB TournamentTeam[]  @relation("TournamentTeamPlayerB")
}

model Session {
  id        String        @id @default(cuid())
  date      DateTime
  location  String?
  createdAt DateTime      @default(now())
  status    SessionStatus @default(UPCOMING)

  attendances   Attendance[]
  rsvps         RSVP[]
  games         Game[]
  ratingHistory RatingHistory[]
  tournament    Tournament?
}

enum SessionStatus {
  UPCOMING
  IN_PROGRESS
  COMPLETED
}

model Attendance {
  id        String  @id @default(cuid())
  sessionId String
  playerId  String
  present   Boolean @default(true)

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  player  Player  @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([sessionId, playerId])
}

enum RSVPStatus {
  GOING
  MAYBE
  OUT
}

model RSVP {
  id        String     @id @default(cuid())
  sessionId String
  playerId  String
  status    RSVPStatus
  updatedAt DateTime   @default(now()) @updatedAt

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  player  Player  @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([sessionId, playerId])
}

model Game {
  id        String   @id @default(cuid())
  sessionId String
  scoreA    Int
  scoreB    Int
  createdAt DateTime @default(now())

  session       Session         @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  teamAPlayers  Player[]        @relation("TeamAPlayers")
  teamBPlayers  Player[]        @relation("TeamBPlayers")
  ratingHistory RatingHistory[]
  video         GameVideo?
  tournamentMatchGames TournamentMatchGame[]
}

model Tournament {
  id             String             @id @default(cuid())
  sessionId      String             @unique
  status         TournamentStatus   @default(ACTIVE)
  teamMode       TournamentTeamMode
  stage          TournamentStage    @default(ROUND_ROBIN)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  endedAt        DateTime?
  winnerTeamId   String?
  specialMode    TournamentSpecialMode @default(NONE)

  session        Session            @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  winnerTeam     TournamentTeam?    @relation("TournamentWinningTeam", fields: [winnerTeamId], references: [id], onDelete: SetNull)
  teams          TournamentTeam[]
  matches        TournamentMatch[]
}

model TournamentTeam {
  id           String       @id @default(cuid())
  tournamentId String
  name         String
  seed         Int
  wins         Int          @default(0)
  losses       Int          @default(0)
  isEliminated Boolean      @default(false)
  createdAt    DateTime     @default(now())

  playerAId    String
  playerBId    String?

  tournament   Tournament   @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  playerA      Player       @relation("TournamentTeamPlayerA", fields: [playerAId], references: [id], onDelete: Cascade)
  playerB      Player?      @relation("TournamentTeamPlayerB", fields: [playerBId], references: [id], onDelete: Cascade)

  matchesAsTeamA TournamentMatch[] @relation("TournamentMatchTeamA")
  matchesAsTeamB TournamentMatch[] @relation("TournamentMatchTeamB")
  winsInMatches TournamentMatch[]  @relation("TournamentMatchWinner")
  lossesInMatches TournamentMatch[] @relation("TournamentMatchLoser")
  wonTournaments Tournament[]      @relation("TournamentWinningTeam")
}

model TournamentMatch {
  id           String               @id @default(cuid())
  tournamentId String
  stage        TournamentMatchStage
  round        Int
  slot         Int
  bestOf       Int                  @default(3)
  winsA        Int                  @default(0)
  winsB        Int                  @default(0)
  isComplete   Boolean              @default(false)
  metadata     Json?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  teamAId      String?
  teamBId      String?
  winnerTeamId String?
  loserTeamId  String?

  teamAPlayerIds String[]
  teamBPlayerIds String[]

  tournament   Tournament           @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  teamA        TournamentTeam?      @relation("TournamentMatchTeamA", fields: [teamAId], references: [id], onDelete: SetNull)
  teamB        TournamentTeam?      @relation("TournamentMatchTeamB", fields: [teamBId], references: [id], onDelete: SetNull)
  winnerTeam   TournamentTeam?      @relation("TournamentMatchWinner", fields: [winnerTeamId], references: [id], onDelete: SetNull)
  loserTeam    TournamentTeam?      @relation("TournamentMatchLoser", fields: [loserTeamId], references: [id], onDelete: SetNull)
  games        TournamentMatchGame[]

  @@index([tournamentId, stage, round, slot])
}

model TournamentMatchGame {
  id                String          @id @default(cuid())
  tournamentMatchId String
  gameId            String
  gameNumber        Int
  createdAt         DateTime        @default(now())

  tournamentMatch   TournamentMatch @relation(fields: [tournamentMatchId], references: [id], onDelete: Cascade)
  game              Game            @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@unique([tournamentMatchId, gameId])
  @@unique([tournamentMatchId, gameNumber])
}

enum TournamentStatus {
  ACTIVE
  COMPLETED
  ENDED
}

enum TournamentTeamMode {
  RANDOM
  FAIR
}

enum TournamentStage {
  ROUND_ROBIN
  BRACKET
  FINALS
  COMPLETED
  ENDED
}

enum TournamentMatchStage {
  ROUND_ROBIN
  BRACKET
  WINNERS_FINAL
  LOSERS_FINAL
}

enum TournamentSpecialMode {
  NONE
  MIXED_ROUND_ROBIN
}

model RatingHistory {
  id           String   @id @default(cuid())
  playerId     String
  sessionId    String
  gameId       String?
  ratingBefore Int
  ratingAfter  Int
  createdAt    DateTime @default(now())

  player  Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  session Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  game    Game?    @relation(fields: [gameId], references: [id], onDelete: SetNull)
}

model Badge {
  id          String        @id @default(cuid())
  code        String        @unique
  name        String
  description String
  iconEmoji   String
  playerBadges PlayerBadge[]
}

model PlayerBadge {
  id        String   @id @default(cuid())
  playerId  String
  badgeId   String
  earnedAt  DateTime @default(now())

  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  badge  Badge  @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([playerId, badgeId])
}

// ============================================
// Push Notification Models
// ============================================

model DeviceToken {
  id        String   @id @default(cuid())
  token     String   @unique  // The APNs device token (hex string)
  platform  String   @default("ios") // "ios" for now, could add "android" later
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============================================
// Video Analysis Models
// ============================================

model GameVideo {
  id       String @id @default(cuid())
  gameId   String @unique
  game     Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)

  s3Key    String // S3 object key
  s3Bucket String // S3 bucket name

  startTime Float? // Trimmed start (seconds)
  endTime   Float? // Trimmed end (seconds)
  duration  Float? // Total duration

  // Net position (marked once, normalized 0-1 coords)
  netX1 Float?
  netY1 Float?
  netX2 Float?
  netY2 Float?

  status    VideoStatus @default(UPLOADED)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  annotations VideoAnnotation[]
  playerTags  VideoPlayerTag[]
}

enum VideoStatus {
  UPLOADING
  UPLOADED
  SETUP_COMPLETE // Players and net tagged
  ANNOTATED
  ERROR
}

// Links detected MediaPipe skeletons to actual players
model VideoPlayerTag {
  id       String    @id @default(cuid())
  videoId  String
  video    GameVideo @relation(fields: [videoId], references: [id], onDelete: Cascade)
  playerId String
  player   Player    @relation(fields: [playerId], references: [id], onDelete: Cascade)

  // Initial position when tagged (for re-identification)
  initialX Float
  initialY Float

  // Color assigned for visualization
  color String

  @@unique([videoId, playerId])
}

model VideoAnnotation {
  id       String    @id @default(cuid())
  videoId  String
  video    GameVideo @relation(fields: [videoId], references: [id], onDelete: Cascade)

  frameTime Float          // Timestamp in video (seconds)
  type      AnnotationType
  playerId  String?
  player    Player?        @relation(fields: [playerId], references: [id], onDelete: Cascade)

  // Position data (normalized 0-1 coordinates) - from MediaPipe
  x Float?
  y Float?

  // For spike accuracy: did ball reach net?
  successful Boolean?

  // For point outcomes: reason
  reason PointReason?

  createdAt DateTime @default(now())
}

enum AnnotationType {
  PLAYER_POSITION // Auto-tracked by MediaPipe
  PASS            // User clicked "Pass"
  SPIKE           // User clicked "Spike"
  POINT_WON       // Point ended - won
  POINT_LOST      // Point ended - lost
}

enum PointReason {
  SERVE_ACE
  GREAT_SPIKE
  OPPONENT_ERROR
  FAILED_RETURN
  NET_VIOLATION
  OUT_OF_BOUNDS
  OTHER
}
